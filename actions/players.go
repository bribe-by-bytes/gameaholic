package actions

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"github.com/gofrs/uuid"
	"bribebybytes.in/gameaholic/models"
)

//TimeLine struct for easy display
type TimeLine struct {
	monthYear   string
	datedEvents []*DatedEvent
}

//DatedEvent struct for easy display
type DatedEvent struct {
	date  string
	event []*Event
}

//Event struct for easy display
type Event struct {
	event         string
	eventProvider string
	eventURL      string
}

//PlayerInfo is queried info all about a player
type PlayerInfo struct {
	ID              uuid.UUID
	Pid             int
	Pname           string
	Pavatar         string
	Pemailid        string
	PcurAchive      string
	Pscore          int
	Plevel          int
	Badges          []string
	PAchivements    []models.PersonalAchievement
	Timelines       []*TimeLine
	BitbucketUname  string
	JiraUname       string
	ConfluenceUname string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Player)
// DB Table: Plural (players)
// Resource: Plural (Players)
// Path: Plural (/players)
// View Template Folder: Plural (/templates/players/)

// PlayersResource is the resource for the Player model
type PlayersResource struct {
	buffalo.Resource
}

// List gets all Players. This function is mapped to the path
// GET /players
func (v PlayersResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	players := []models.Player{}

	// playees := &models.Players{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	//q := tx.PaginateFromParams(c.Params())
	query := tx.Order("pscore desc")

	// err := query.All(&levels)
	// Retrieve all Players from the DB
	if err := query.All(&players); err != nil {
		fmt.Println("Failed to fetch all players")
		return err
	}

	var playerInfos = make([]PlayerInfo, len(players))

	fmt.Println("Player records retrieved: %s. This first email being: %s", len(players), players[0].Pemailid)

	var badges []string

	for i := 0; i < len(players); i++ {
		playerInfos[i].ID = players[i].ID
		playerInfos[i].Pid = players[i].Pid
		playerInfos[i].Pname = players[i].Pname
		playerInfos[i].Pavatar = players[i].Pavatar
		playerInfos[i].Pemailid = players[i].Pemailid
		playerInfos[i].PcurAchive = players[i].PcurAchive
		playerInfos[i].Pscore = players[i].Pscore
		playerInfos[i].Plevel = players[i].Plevel
		playerInfos[i].BitbucketUname = players[i].BitbucketUname
		playerInfos[i].JiraUname = players[i].JiraUname
		playerInfos[i].ConfluenceUname = players[i].ConfluenceUname
		playerInfos[i].CreatedAt = players[i].CreatedAt
		playerInfos[i].UpdatedAt = players[i].UpdatedAt
		fmt.Println("Player records retrieved: %s. This first email being: %s", len(players), players[i].Pavatar)

		badges, _ = RetrieveLevels(c, players[i].Plevel)

		playerInfos[i].Badges = badges
		playerInfos[i].PAchivements = RetrievePAchievements(c, players[i].Pid)

		fmt.Println("Player badges retrieved: %v", playerInfos[i].Badges)

	}

	// Add the paginator to the context so it can be used in the template.
	//c.Set("pagination", q.Paginator)

	return c.Render(http.StatusOK, r.Auto(c, playerInfos))
}

// Show gets the data for one Player. This function is mapped to
// the path GET /players/{player_id}
func (v PlayersResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Player
	player := &models.Player{}

	// To find the Player the parameter player_id is used.
	if err := tx.Find(player, c.Param("player_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	println(c.Params())

	badges, err := RetrieveLevels(c, player.Plevel)

	timelines, err := RetrieveTimelines(c, player.Pid)

	fmt.Println("Timeline for rendering: %v", timelines)

	if err != nil {
		return c.Error(http.StatusInternalServerError, err)
	}

	var playerInfo PlayerInfo

	playerInfo.ID = player.ID
	playerInfo.Pid = player.Pid
	playerInfo.Pname = player.Pname
	playerInfo.Pavatar = player.Pavatar
	playerInfo.Pemailid = player.Pemailid
	playerInfo.PcurAchive = player.PcurAchive
	playerInfo.Pscore = player.Pscore
	playerInfo.Plevel = player.Plevel
	playerInfo.BitbucketUname = player.BitbucketUname
	playerInfo.JiraUname = player.JiraUname
	playerInfo.ConfluenceUname = player.ConfluenceUname
	playerInfo.CreatedAt = player.CreatedAt
	playerInfo.UpdatedAt = player.UpdatedAt
	playerInfo.Badges = badges
	playerInfo.PAchivements = RetrievePAchievements(c, player.Pid)
	playerInfo.Timelines = timelines

	return c.Render(http.StatusOK, r.Auto(c, playerInfo))
}

// New renders the form for creating a new Player.
// This function is mapped to the path GET /players/new
func (v PlayersResource) New(c buffalo.Context) error {
	return c.Render(http.StatusOK, r.Auto(c, &models.Player{}))
}

// Create adds a Player to the DB. This function is mapped to the
// path POST /players
func (v PlayersResource) Create(c buffalo.Context) error {
	// Allocate an empty Player
	player := &models.Player{}

	// Bind player to the html form elements
	if err := c.Bind(player); err != nil {
		return err
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(player)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(http.StatusUnprocessableEntity, r.Auto(c, player))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", T.Translate(c, "player.created.success"))
	// and redirect to the players index page
	return c.Render(http.StatusCreated, r.Auto(c, player))
}

// Edit renders a edit form for a Player. This function is
// mapped to the path GET /players/{player_id}/edit
func (v PlayersResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Player
	player := &models.Player{}

	if err := tx.Find(player, c.Param("player_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	return c.Render(http.StatusOK, r.Auto(c, player))
}

// Update changes a Player in the DB. This function is mapped to
// the path PUT /players/{player_id}
func (v PlayersResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Player
	player := &models.Player{}

	if err := tx.Find(player, c.Param("player_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	// Bind Player to the html form elements
	if err := c.Bind(player); err != nil {
		return err
	}

	verrs, err := tx.ValidateAndUpdate(player)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the edit.html template that the user can
		// correct the input.
		return c.Render(http.StatusUnprocessableEntity, r.Auto(c, player))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", T.Translate(c, "player.updated.success"))
	// and redirect to the players index page
	return c.Render(http.StatusOK, r.Auto(c, player))
}

//RetrievePAchievements will retrieve personalAchievements for given player
func RetrievePAchievements(c buffalo.Context, playerid int) []models.PersonalAchievement {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		fmt.Errorf("no transaction found")
	}
	// Allocate an empty Player
	personalAchievements := []models.PersonalAchievement{}

	query := tx.Where("player_id = ?", playerid).Order("created_at desc")

	err := query.All(&personalAchievements)

	if err != nil {
		fmt.Print("ERROR!\n")
		fmt.Printf("%v\n", err)
	} else {
		fmt.Print("Success!\n")
		fmt.Printf("%v\n", personalAchievements)
	}

	return personalAchievements

}

// Find takes a slice and looks for an element in it. If found it will
// return it's key, otherwise it will return -1 and a bool of false.
func FindTimeline(slice []*TimeLine, val string) (int, bool) {
	for i, item := range slice {
		if item.monthYear == val {
			return i, true
		}
	}
	return -1, false
}

func FindDatedEvents(slice []*DatedEvent, val string) (int, bool) {
	for i, item := range slice {
		if item.date == val {
			return i, true
		}
	}
	return -1, false
}

func RetrieveTimelines(c buffalo.Context, playerId int) ([]*TimeLine, error) {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return nil, fmt.Errorf("no transaction found")
	}
	// Allocate an empty Player
	playerTimelines := []models.PlayerTimeline{}

	query := tx.Where("player_id <= ?", playerId).Order("created_at desc")

	err := query.All(&playerTimelines)
	fmt.Println("Timeline Count %s", len(playerTimelines))

	var timelines = []*TimeLine{}
	var datedEvent *DatedEvent
	datedEvent = new(DatedEvent)
	var event *Event
	event = new(Event)
	var monthYear string

	for i := 0; i < len(playerTimelines); i++ {
		timeline := new(TimeLine)

		fmt.Println("progress")

		monthYear = playerTimelines[i].CreatedAt.Format("Jul 1988")
		event.event = playerTimelines[i].Event
		event.eventProvider = playerTimelines[i].EventProvider
		event.eventURL = playerTimelines[i].EventURL
		fmt.Println("progress")

		datedEvent.date = playerTimelines[i].CreatedAt.Format("21, Tuesday")
		datedEvent.event = append(datedEvent.event, event)

		fmt.Println("progress")

		fmt.Println("progress")

		key, found := FindTimeline(timelines, monthYear)

		if i == 0 || !found {
			timeline.monthYear = monthYear
			timelines = append(timelines, timeline)
		}

		key, found = FindTimeline(timelines, monthYear)
		fmt.Println("progress %s", key)
		keyDate, foundDate := FindDatedEvents(timelines[key].datedEvents, datedEvent.date)
		if !foundDate {
			timelines[key].datedEvents = append(timelines[key].datedEvents, datedEvent)
		}

		keyDate, foundDate = FindDatedEvents(timelines[key].datedEvents, datedEvent.date)
		fmt.Println("progress %s", keyDate)

		timelines[key].datedEvents[keyDate].event = append(timelines[key].datedEvents[keyDate].event, event)

		fmt.Println("Timeline so far : %v", timelines)
	}

	if err != nil {
		fmt.Print("ERROR!\n")
		fmt.Printf("%v\n", err)
	} else {
		fmt.Print("Success!\n")
	}

	return timelines, nil
}

//RetrieveLevels will retrieve level badges for given player
func RetrieveLevels(c buffalo.Context, playerlevel int) ([]string, error) {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return nil, fmt.Errorf("no transaction found")
	}
	// Allocate an empty Player
	levels := []models.Level{}

	var badges []string

	query := tx.Where("l_id <= ?", playerlevel).Order("l_id asc")

	err := query.All(&levels)
	fmt.Println("Level Count %s", len(levels))

	for i := 0; i < len(levels); i++ {
		badges = append(badges, levels[i].Aavatar)
		fmt.Println("Badges %s", badges[i])
	}

	if err != nil {
		fmt.Print("ERROR!\n")
		fmt.Printf("%v\n", err)
	} else {
		fmt.Print("Success!\n")
		fmt.Printf("%v\n", levels)
	}

	return badges, nil

}

// Destroy deletes a Player from the DB. This function is mapped
// to the path DELETE /players/{player_id}
func (v PlayersResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Player
	player := &models.Player{}

	// To find the Player the parameter player_id is used.
	if err := tx.Find(player, c.Param("player_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	if err := tx.Destroy(player); err != nil {
		return err
	}

	// If there are no errors set a flash message
	c.Flash().Add("success", T.Translate(c, "player.destroyed.success"))
	// Redirect to the players index page
	return c.Render(http.StatusOK, r.Auto(c, player))
}
